data$OCDE <- as.factor(data$OCDE)
data_numeric <- data[, sapply(data, is.numeric)]
Stat_descriptives = describe(data_numeric, skew  = FALSE)
Stat_descriptives[,c("mean","median","min","max","range","se")]
library(ggplot2)
# histogramme de la variable cible
ggplot(data, aes(x=happiness_moyenne)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
knitr::opts_chunk$set(cache = TRUE) #Activer le cache des chunks pour accélérer les recompilations
options("install.lock"=FALSE) #Désactiver le verrouillage d’installation des packages
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
install.packages("pastecs")
library(pastecs)
library(psych)
library(ggplot2)
# histogramme de la variable cible
ggplot(data, aes(x=happiness_moyenne)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
install.packages("pastecs")
ggplot(data, aes(x=happiness_moyenne)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
plots <- list()
for (i in 1:ncol(data_numeric)) {
p <- ggplot(data_numeric, aes_string(x=data_numeric[[i]])) +
geom_histogram(binwidth=diff(range(data_numeric[[i]]))/30, fill="green", color="black", alpha=0.7) +
labs(x=colnames(data_numeric)[i], y="") +
theme_minimal() +
theme(plot.margin = grid::unit(c(0.5,0.5,0.5,0.5), "cm"))
plots[[i]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 2
do.call(grid.arrange, c(plots, ncol = ncol_plot))
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
# boxplot de la variable cible
ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
# histogramme de la variable cible
a = ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
# boxplot de la variable cible
b = ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
do.call(grid.arrange, c(plots, ncol = 2))
l = list(a,b)
do.call(grid.arrange, c(l, ncol = 2))
do.call(grid.arrange, c(l, ncol = 1))
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
# boxplot de la variable cible
ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
###library
library(AER) # Functions, data sets, examples, demos, and vignettes for the book Christian Kleiber and Achim Zeileis (2008), Applied Econometrics with R, Springer-Verlag, New York
library(car) #car: Companion to Applied Regression
# Functions to Accompany J. Fox and S. Weisberg, An R Companion to Applied Regression, Third Edition, Sage, 2019.
library(sandwich) # Robust Covariance Matrix Estimators
library(lmtest) #Testing Linear Regression Models
#A collection of tests, data sets, and examples for diagnostic checking in linear regression models. Furthermore, some generic tools for inference in parametric models are provided
library(ggplot2) #Create Elegant Data Visualisations Using the Grammar of Graphics
library(corrplot) #Provides a visual exploratory tool on correlation matrix that supports automatic variable reordering to help detect hidden patterns among variables
### Working directory
getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
###library
library(AER) # Functions, data sets, examples, demos, and vignettes for the book Christian Kleiber and Achim Zeileis (2008), Applied Econometrics with R, Springer-Verlag, New York
library(car) #car: Companion to Applied Regression
# Functions to Accompany J. Fox and S. Weisberg, An R Companion to Applied Regression, Third Edition, Sage, 2019.
library(sandwich) # Robust Covariance Matrix Estimators
library(lmtest) #Testing Linear Regression Models
#A collection of tests, data sets, and examples for diagnostic checking in linear regression models. Furthermore, some generic tools for inference in parametric models are provided
library(ggplot2) #Create Elegant Data Visualisations Using the Grammar of Graphics
library(corrplot) #Provides a visual exploratory tool on correlation matrix that supports automatic variable reordering to help detect hidden patterns among variables
### Working directory
getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Récupération des données
#data_TD3 <-
#Je vous propose aussi des visuels plus faciles à lire grâce au package STARGAZER, vous avez la documentation et l'aide sur moodle sur ces fonctions
install.packages("stargazer")
library(stargazer)
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
data_TD3 = read.cdv("CO2_Kuznets.csv")
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
data_TD3 = read.csv("CO2_Kuznets.csv")
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
data_TD3 = read.csv("CO2_Kuznets.csv", header = TRUE)
#on supprime les colonnes  qui ne sont pas intéressantes dans ce TD
data_TD3 = read.csv("CO2_Kuznets.csv", header = TRUE, sep = ";", dec= ",")
View(data_TD3)
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
summary(Data_statdesc)
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
names(data_TD3) = c("Country","CO2pc","GDPpcppp","Industry","Energypc","Fossil","Renewable","Servers","Internet","OECD")
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
summary(Data_statdesc)
#autres options avec un tableau plus agréable à lire
stargazer(Data_statdesc, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
Data_statdesc
#autres options avec un tableau plus agréable à lire
stargazer(Data_statdesc, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
#tableau de statistiques descriptives en fonction des membres OECD
tapply(data_TD3$CO2pc, data_TD3$OECD, summary)
#besoin d'un facteur pour le graphique
data_TD3$OECD_f <-as.factor(data_TD3$OECD )
library(hrbrthemes)
#  CO2 OECD ou non
ggplot( data_TD3, aes(x=OECD_f, y=CO2pc, fill=OECD_f)) +
geom_boxplot() +
scale_fill_viridis(discrete = TRUE, alpha=0.6) +
theme(
legend.position="none",
plot.title = element_text(size=11)
) +
ggtitle("Boxplot du CO2 par habitant par pays membres OECD") +
xlab("")
# basic nuage de point (scatterplot)
ggplot(data_TD3, aes(x=CO2pc, y=GDPpcppp)) +
geom_point()
# Il y a des individus avec des valeurs atypiques qui pourraient influencer la qualité des résultats.
# basic nuage de point (scatterplot)
ggplot(data_TD3, aes(x=CO2pc, y=log(GDPpcppp)) )+
geom_point()
# basic nuage de point (scatterplot)
ggplot(data_TD3, aes(x=log(CO2pc), y=log(GDPpcppp)) )+
geom_point()
# Sur ce dernier graphique la relation semble bien plus linéaire et le modèle qui en découle devrait être de meilleur qualité, on s'attend à avoir une relation positive entre le stade de développement des pays et leur niveau de pollution.
reg1 <- lm( CO2pc ~ GDPpcppp + Industry + OECD, data=data_TD3)
# Description des résultats
summary(reg1)
# Commenter R2 ajusté, modèle globalement satisfaisant, variable significatif
# Pour éviter des coefficients trop petits à interpréter on va transformer la variable GDPpcppp en milliers de dollars international constant 2017
data_TD3$GDPpcppp <- data_TD3$GDPpcppp/1000
# Comparaison des résultats = même coefficient seule l'échelle / unité a changé = modèle 2
# Modèle niveau / niveau
reg2 <- lm( CO2pc ~ GDPpcppp + Industry + OECD, data=data_TD3)
# Description des résultats
stargazer(reg1,reg2,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
#modèle niveau / log
reg3 <- lm( CO2pc ~ log(GDPpcppp) + Industry + OECD, data=data_TD3)
#modèle log / niveau
reg4<- lm( log(CO2pc) ~ GDPpcppp + Industry + OECD, data=data_TD3)
#modèle log / log
reg5 <- lm( log(CO2pc) ~ log(GDPpcppp) + Industry + OECD, data=data_TD3)
#visualisation des résultats au sein d'un même tableau
stargazer(reg2, reg3, reg4, reg5,   title="Modèles de régression log linéaire",align=TRUE, type="text", digits=3)
#création de la variable au carré pour tester un modèle quadratique
data_TD3$GDPpcppp_2 <- data_TD3$GDPpcppp*data_TD3$GDPpcppp
reg6 <- lm( log(CO2pc) ~ GDPpcppp + GDPpcppp_2+ Industry + OECD, data=data_TD3)
stargazer(reg6,   title="Modèles de régression quadratique",align=TRUE, type="text", digits=3)
#effets croisés PIB/hab x OECD
reg7 <- lm( log(CO2pc) ~ log(GDPpcppp)*OECD + Industry , data=data_TD3)
stargazer(reg7,   title="Modèles de régression avec des effets croisés",align=TRUE, type="text", digits=3)
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal() +
stat_function(fun = dnorm, args = list(mean = mean(data$Happiness), sd = sd(data$Happiness)))
# boxplot de la variable cible
ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal() +
stat_function(fun = dnorm, args = list(mean = mean(data$Happiness), sd = sd(data$Happiness)),size = 5)
# boxplot de la variable cible
ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
# boxplot de la variable cible
ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
stargazer(Data_statdesc, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
Stat_descriptives =Stat_descriptives[,c("mean","median","min","max","range","se")]
stargazer(Stat_descriptives, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
#tableau de statistiques descriptives en fonction des membres OECD
tapply(data_TD3$CO2pc, data_TD3$OECD, summary)
Data_statdesc<- data_TD3[,c("CO2pc","GDPpcppp","Industry","OECD")]
Data_statdesc
Stat_descriptives
summary(Data_statdesc)
Data_statdesc
stargazer(data_numeric, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
?stargazer
stargazer(data_numeric, median = TRUE, type = "text", title="Descriptive statistics", digits=2, out="stat_desc.txt")
stargazer(data_numeric, median = TRUE, type = "text", title="Statistiques descriptives ", digits=2)
# import des données
data = read.csv(file = 'donnees.csv')[,-1]
head(data)
#transform OCDE variable into factor
data$OCDE <- as.factor(data$OCDE)
data_numeric <- data[, sapply(data, is.numeric)]
stargazer(data_numeric, median = TRUE, type = "text", title="Statistiques descriptives ", digits=2)
# Etude des statistiques descriptives
data_numeric <- data[, sapply(data, is.numeric)]
stargazer(data_numeric, median = TRUE, type = "text", title="Statistiques descriptives ", digits=2)
# import des données
data = read.csv(file = 'donnees.csv')[,-1]
head(data)
#transform OCDE variable into factor
data$OCDE <- as.factor(data$OCDE)
# import des données
data = read.csv(file = 'donnees.csv', row.names = 1)[,-1]
head(data)
# import des données
data = read.csv(file = 'donnees.csv', row.names = 2)[,-1]
head(data)
plots <- list()
for (i in 1:ncol(data_numeric)) {
p <- ggplot(data_numeric, aes_string(x=data_numeric[[i]])) +
geom_histogram(binwidth=diff(range(data_numeric[[i]]))/30, fill="green", color="black", alpha=0.7) +
labs(x=colnames(data_numeric)[i], y="") +
theme_minimal() +
theme(plot.margin = grid::unit(c(0.5,0.5,0.5,0.5), "cm"))
plots[[i]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 2
do.call(grid.arrange, c(plots, ncol = ncol_plot))
# histogramme de la variable cible
ggplot(data, aes(x=Happiness)) +
geom_histogram(binwidth=0.25, fill="blue", color="black", alpha=0.7) +
labs(title="Histogramme du score de bonheur", x="Score de bonheur", y="Fréquence") +
theme_minimal()
# boxplot de la variable cible
ggplot(data, aes(y=Happiness)) +
geom_boxplot(fill="orange", color="black", alpha=0.7) +
labs(title="Boxplot du score de bonheur", y="Score de bonheur") +
theme_minimal()
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$happiness_moyenne, data_numeric[[v]]))
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted, horiz = TRUE, las = 1,
# gradient color from cor
col = viridis::viridis(length(cors_sorted), alpha = 0.8)[rank(cors_sorted)],
xlab = "Corrélation avec happiness_moyenne",
main = "Corrélations des variables explicatives")
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
scatter_plots <- list()
for (i in 3:ncol(data[,-ncol(data)])) {
p <- ggplot(data, aes_string(x=data[[i]], y="Indice_bonheur")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Indice_bonheur") +
theme_minimal()
scatter_plots[[i-2]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
scatter_plots <- list()
for (i in 3:ncol(data[,-ncol(data)])) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-2]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
scatter_plots <- list()
for (i in 2:ncol(data[,-ncol(data)])) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-2]] <- p
}
scatter_plots <- list()
for (i in 3:ncol(data[,-ncol(data)])) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-2]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
scatter_plots <- list()
c(2:11,13)
for (i in c(2:11,13)) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-1]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
scatter_plots
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-1]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
scatter_plots
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-1]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
# premier modèle : toutes les variables candidates
reg1 <- lm(Happiness ~ Political_Corruption + KWH_pp_pc + GDP_per_Capita + Lifespan + Net_Migration + Overweight_Adults + Population_Density + Military_Expenses + Population_Growth + OCDE + Primary_School_enrollment, data = data)
# premier modèle : toutes les variables candidates
reg1 <- lm(Happiness ~ Political_Corruption + KWH_pp_pc + GDP_per_Capita + Lifespan + Net_Migration + Overweight_Adults + Population_Density + Military_Expenses + Population_Growth + OCDE + Primary_School_Enrollment, data = data)
cat('\n--- Résumé du modèle (reg1) ---\n')
print(summary(reg1))
plots[6]
plots[11]
plots = plots[-11]
do.call(grid.arrange, c(plots, ncol = ncol_plot))
# corrplot
library(corrplot)
# analyse sans Country.name et Code, et sans happiness moyenne
corrplot(cor(data_numeric[,-ncol(data)]), method="shade", type = "lower", tl.col="black", tl.srt=45)
# Corrélation entre les variables explicatives
library(corrplot)
corrplot(cor(data_numeric[,-ncol(data)]), method="shade", type = "lower", tl.col="black", tl.srt=45)
data_numeric
View(data_numeric)
View(data_numeric[,-ncol(data)])
View(data_numeric[,-ncol(data_numeric)])
corrplot(cor(data_numeric[,-ncol(data_numeric)]), method="shade", type = "lower", tl.col="black", tl.srt=45)
# VIF pour contrôler la multicolinéarité (si package car installé)
if (requireNamespace('car', quietly = TRUE)) {
library(car)
cat('\nVIF:\n')
print(vif(reg1))
} else cat('\nInstaller le package car pour calculer le VIF : install.packages("car")\n')
# Test d'hétéroscédasticité (Breusch-Pagan) et coefficients robustes HC1
if (requireNamespace('lmtest', quietly = TRUE) && requireNamespace('sandwich', quietly = TRUE)) {
library(lmtest); library(sandwich)
cat('\nBreusch-Pagan test :\n')
print(bptest(reg1))
cat('\nCoefficients avec erreurs robustes (HC1) :\n')
print(lmtest::coeftest(reg1, vcov. = sandwich::vcovHC(reg1, type = 'HC1')))
} else cat('\nInstaller lmtest et sandwich pour tests et erreurs robustes\n')
# Diagnostics graphiques rapides
par(mfrow = c(2,2))
plot(reg1)
par(mfrow = c(1,1))
print(summary(reg1))
knitr::opts_chunk$set(cache = TRUE) #Activer le cache des chunks pour accélérer les recompilations
options("install.lock"=FALSE) #Désactiver le verrouillage d’installation des packages
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
library(pastecs)
library(psych)
library(ggplot2)
stargazer(data_numeric, median = TRUE, type = "text", title="Statistiques descriptives ", digits=2)
library(stargazer)
library(pastecs)
do.call(grid.arrange, c(plots[4,8,9,10], ncol = ncol_plot))
do.call(grid.arrange, c(plots[4,8,9,10], ncol = 2))
plots[4,8,9,10]
plots[4]
plots[c(4,8,9,10)]
do.call(grid.arrange, c(plots[c(4,8,9,10)], ncol = 2))
do.call(grid.arrange, c(plots[c(2,6,7)], ncol = 2))
do.call(grid.arrange, c(plots[c(2,6,7)], ncol = 3))
do.call(grid.arrange, c(plots[c(2,6,7)], ncol = 2))
do.call(grid.arrange, c(plots[c(1,3,5)], ncol = 2))
do.call(grid.arrange, c(plots[c(4,8,9,10)], ncol = 2))
plots <- list()
for (i in 1:ncol(data_numeric)) {
p <- ggplot(data_numeric, aes_string(x=data_numeric[[i]])) +
geom_histogram(binwidth=diff(range(data_numeric[[i]]))/30, fill="green", color="black", alpha=0.7) +
labs(x=colnames(data_numeric)[i], y="") +
theme_minimal() +
theme(plot.margin = grid::unit(c(0.5,0.5,0.5,0.5), "cm"))
plots[[i]] <- p
}
plots = plots[-11]
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 2
#do.call(grid.arrange, c(plots, ncol = ncol_plot))
do.call(grid.arrange, c(plots[c(4,8,9,10)], ncol = 2))
do.call(grid.arrange, c(plots, ncol = ncol_plot))
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted, horiz = TRUE, las = 1,
# gradient color from cor
col = viridis::viridis(length(cors_sorted), alpha = 0.8)[rank(cors_sorted)],
xlab = "Corrélation avec happiness_moyenne",
main = "Corrélations des variables explicatives")
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-1]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
do.call(grid.arrange, c(plots, ncol = ncol_plot))
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted, horiz = TRUE, las = 1,
# gradient color from cor
col = viridis::viridis(length(cors_sorted), alpha = 0.8)[rank(cors_sorted)],
xlab = "Corrélation avec happiness_moyenne",
main = "Corrélations des variables explicatives")
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x=data[[i]], y="Happiness")) +
geom_point() +
geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
labs(x=colnames(data)[i], y="Happiness") +
theme_minimal()
scatter_plots[[i-1]] <- p
}
library(gridExtra)
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = ncol_plot))
do.call(grid.arrange, c(plots[c(4,8,9,10)], ncol = 2))
