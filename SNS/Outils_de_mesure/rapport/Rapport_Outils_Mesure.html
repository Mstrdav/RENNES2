<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>rapport_outils_mesure</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Rapport_Outils_Mesure_files/libs/clipboard/clipboard.min.js"></script>
<script src="Rapport_Outils_Mesure_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Rapport_Outils_Mesure_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Rapport_Outils_Mesure_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="Rapport_Outils_Mesure_files/libs/quarto-html/popper.min.js"></script>
<script src="Rapport_Outils_Mesure_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Rapport_Outils_Mesure_files/libs/quarto-html/anchor.min.js"></script>
<link href="Rapport_Outils_Mesure_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Rapport_Outils_Mesure_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Rapport_Outils_Mesure_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Rapport_Outils_Mesure_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Rapport_Outils_Mesure_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="rapport-détude-validation-de-capteurs-de-puissance-wahoo-kickr-vs-favero-assioma-duo" class="level1">
<h1>Rapport d’Étude : Validation de Capteurs de Puissance (Wahoo KickR vs Favero Assioma Duo)</h1>
<p><strong>Auteurs :</strong> Colin Geindre &amp; Binôme <strong>Date :</strong> 13/02/2026 <strong>Contexte :</strong> Master SNS / Outils de Mesure</p>
<hr>
<section id="partie-1-fonctionnement-des-outils-de-mesures" class="level2">
<h2 class="anchored" data-anchor-id="partie-1-fonctionnement-des-outils-de-mesures">Partie 1 : Fonctionnement des outils de mesures</h2>
<section id="puissance-mécanique-de-pédalage" class="level3">
<h3 class="anchored" data-anchor-id="puissance-mécanique-de-pédalage">1. Puissance mécanique de pédalage</h3>
<p>La puissance mécanique (<span class="math inline">\(P\)</span>) est le produit du couple (<span class="math inline">\(C\)</span>) appliqué sur les pédales et de la vitesse angulaire de pédalage (<span class="math inline">\(\omega\)</span>). <span class="math display">\[ P = C \times \omega \]</span> Elle s’exprime en Watts (W). <span class="math inline">\(C\)</span> est en Newton-mètre (N.m) et <span class="math inline">\(\omega\)</span> en radians/seconde (rad/s).</p>
</section>
<section id="méthodes-de-mesure" class="level3">
<h3 class="anchored" data-anchor-id="méthodes-de-mesure">2. Méthodes de mesure</h3>
<ul>
<li><strong>Wahoo KickR (Home Trainer) :</strong> Mesure la puissance au niveau de la cassette (hub arrière). Il estime le couple via le frein électromagnétique et mesure la vitesse de rotation de la cassette (liée à la cadence par le braquet).</li>
<li><strong>Favero Assioma Duo (Pédales) :</strong> Mesure la puissance directement au point d’application de la force. Chaque pédale contient des jauges de contrainte (strain gauges) pour mesurer la force tangentielle (et donc le couple) et un accéléromètre/gyroscope pour la vitesse angulaire instantanée (IAV).</li>
</ul>
</section>
<section id="avantages-et-limites" class="level3">
<h3 class="anchored" data-anchor-id="avantages-et-limites">3. Avantages et Limites</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 40%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Outil</th>
<th>Avantages</th>
<th>Limites</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Wahoo KickR</strong></td>
<td>Stabilité, contrôle de la résistance (Erg mode), pas de problème d’installation.</td>
<td>Mesure après la transmission (pertes chaîne ~2-3%), inertie du volant, nécessite un vélo.</td>
</tr>
<tr class="even">
<td><strong>Favero Assioma</strong></td>
<td>Mesure directe (source), portable (sur n’importe quel vélo), analyse G/D.</td>
<td>Installation (couple de serrage), calibration requise, fragile (chocs).</td>
</tr>
</tbody>
</table>
</section>
<section id="outil-de-référence" class="level3">
<h3 class="anchored" data-anchor-id="outil-de-référence">4. Outil de Référence</h3>
<p><strong>Favero Assioma Duo</strong> est considéré comme l’outil de référence (“Gold Standard” terrain) pour la puissance physiologique produite par le cycliste, car il mesure avant les pertes mécaniques de la transmission. Le Wahoo mesure la puissance <em>transmise</em> à la route (ou au volant), ce qui est différent de la puissance <em>produite</em>.</p>
<hr>
</section>
</section>
<section id="partie-2-validation-du-capteur-de-puissance" class="level2">
<h2 class="anchored" data-anchor-id="partie-2-validation-du-capteur-de-puissance">Partie 2 : Validation du capteur de puissance</h2>
<section id="protocole-de-validation" class="level3">
<h3 class="anchored" data-anchor-id="protocole-de-validation">1. Protocole de validation</h3>
<p>L’étude compare les données de puissance issues des deux capteurs enregistrées simultanément lors de deux types d’efforts : * <strong>Steady State :</strong> Paliers stables à cadence fixée (70 rpm et 90 rpm). * <strong>Sprints :</strong> Efforts maximaux brefs pour évaluer la réactivité et les pics de puissance.</p>
<p><strong>Synchronisation :</strong> Les fichiers bruts (.fit) ont été synchronisés temporellement par une méthode de corrélation croisée (Cross-Correlation) sur le signal de puissance afin de corriger les décalages d’horloge.</p>
</section>
<section id="limites-et-améliorations" class="level3">
<h3 class="anchored" data-anchor-id="limites-et-améliorations">2. Limites et Améliorations</h3>
<ul>
<li><strong>Problème identifié (70 rpm) :</strong> Une divergence majeure a été observée sur les essais à 70 rpm (Wahoo ~50W vs Assioma ~130W). Cela suggère un défaut de calibration du Wahoo à basse intensité/cadence, ou un mode “Erg” mal réglé. Ces données ont été exclues de l’analyse de corrélation finale.</li>
<li><strong>Synchronisation Sprints :</strong> Les fichiers de sprints présentaient des décalages temporels importants et une faible corrélation, rendant l’analyse point par point difficile.</li>
<li><strong>Amélioration :</strong> Utiliser un compteur unique (head unit) appairé aux deux capteurs simultanément (si possible) ou effectuer un “top départ” (marker) visible dans les données (ex: 3 coups de pédale à vide) pour faciliter l’alignement.</li>
</ul>
</section>
<section id="reproductibilité-intra-individuelle-sprints" class="level3">
<h3 class="anchored" data-anchor-id="reproductibilité-intra-individuelle-sprints">3. Reproductibilité intra-individuelle (Sprints)</h3>
<p>L’analyse des pics de puissance sur les sprints montre une variabilité. Le Coefficient de Variation (CV) intra-individuel permettrait de quantifier cette reproductibilité. (Données brutes non exploitables avec précision pour ce calcul suite aux problèmes de sync).</p>
</section>
<section id="corrélation-données-valides" class="level3">
<h3 class="anchored" data-anchor-id="corrélation-données-valides">4. Corrélation (Données Valides)</h3>
<p>Sur les enregistrements valides (principalement 90 rpm, ~120W), nous obtenons une <strong>forte corrélation</strong> (<span class="math inline">\(r \approx 0.85 - 0.96\)</span>) pour les sujets Anton, MathisW, Tristan, NathanM, MathisM, Jonathan, Sacha. Cela indique que les deux capteurs suivent la même tendance d’évolution de puissance.</p>
</section>
<section id="comparaison-des-moyennes-biais" class="level3">
<h3 class="anchored" data-anchor-id="comparaison-des-moyennes-biais">5. Comparaison des Moyennes (Biais)</h3>
<p>Sur le groupe “Valide” (Steady State ~120W) : * <strong>Moyenne Wahoo :</strong> 122.5 W * <strong>Moyenne Assioma :</strong> 116.5 W * <strong>Biais moyen :</strong> +6 W (Wahoo &gt; Assioma).</p>
<p><em>Interprétation :</em> Ce résultat est contre-intuitif (le Wahoo en bout de chaîne devrait mesurer moins). Cela confirme une surestimation probable du Wahoo KickR ou une sous-estimation des pédales (calibration).</p>
</section>
<section id="analyse-de-bland-altman" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-bland-altman">6. Analyse de Bland-Altman</h3>
<p>L’analyse de Bland-Altman sur les données synchronisées montre : * Un biais systématique positif du Wahoo. * Une dispersion (limites d’agrément) raisonnable pour les données à 90 rpm (<span class="math inline">\(\pm 10-15\)</span> W), mais inacceptable pour les données à 70 rpm (&gt; 100 W de différence).</p>
<hr>
</section>
</section>
<section id="partie-3-compte-rendu-client-synthèse" class="level2">
<h2 class="anchored" data-anchor-id="partie-3-compte-rendu-client-synthèse">Partie 3 : Compte-rendu client (Synthèse)</h2>
<p><strong>Objet : Rapport de validation du prototype de mesure de puissance Wahoo KickR</strong></p>
<p>Madame, Monsieur,</p>
<p>Suite à la campagne de mesures effectuée le 15/01/2026, comparant votre dispositif Wahoo KickR aux pédales de référence Favero Assioma Duo, voici nos conclusions :</p>
<p><strong>1. Fiabilité Globale :</strong> Le dispositif montre une <strong>très bonne corrélation (<span class="math inline">\(r &gt; 0.9\)</span>)</strong> avec la référence sur des efforts d’intensité moyenne à cadence élevée (90 rpm, ~120W). Il capture fidèlement les variations de puissance du cycliste.</p>
<p><strong>2. Biais de Mesure :</strong> Nous observons une <strong>surestimation systématique de la puissance</strong> de l’ordre de <strong>+5 à +6%</strong> par rapport à la référence sur les plages stabilisées. Bien que précis (répétable), l’outil manque d’exactitude (justesse) dans sa configuration actuelle.</p>
<p><strong>3. Point de Vigilance Majeur (Faibles Intensités) :</strong> Des écarts critiques ont été relevés lors des phases à basse cadence (70 rpm) et faible résistance, où le Wahoo sous-estime drastiquement la puissance réelle (50W mesurés contre 130W réels). Ce comportement suggère un défaut de linéarité ou de calibration à bas régime.</p>
<p><strong>Recommandations :</strong> * Effectuer une calibration d’usine (Spindown) avant chaque utilisation critique. * Investiguer la linéarité du frein électromagnétique à basse vitesse de rotation (&lt; 75 rpm). * Appliquer un facteur correctif de -5% pour les intensités cibles &gt; 100W.</p>
<p><strong>Conclusion :</strong> Le Wahoo KickR est un outil valide pour l’entraînement à intensité modérée/haute, sous réserve de correction du biais. Il n’est pas validé pour les mesures de précision à basse intensité (&lt; 100W / 70 rpm) dans l’état actuel.</p>
<p><strong>L’équipe Data Science Performance</strong> M1 SNS - Rennes 2</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>